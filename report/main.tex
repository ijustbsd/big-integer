\section{Постановка задачи}

\begin{enumerate}
    \item Составьте алгоритм (в виде блок-схемы) и напишите (на любом языке программирования) соответствующую ему программу, позволяющую выполнять арифметические операции (сложение, вычитание, умножение и деление) над длинными целыми числами;
    \item Составьте алгоритм и напишите соответствующую ему программу, позволяющую возводить натуральное число в натуральную степень;
    \item Cоставьте алгоритм и напишите соответствующую ему программу, позволяющую вычислять целую часть корня произвольной степени $m > 0$ из натурального числа;
    \item Используя один из предложенных выше алгоритмов, составьте блок-схему и напишите соответствующую ей программу, позволяющую вычислять наибольший общий делитель двух больших натуральных чисел;
    \item Составьте алгоритм и напишите соответствующую ему программу, позволяющую выполнять операции сложения, вычитания и умножения в кольце вычетов;
    \item Составьте алгоритм и напишите соответствующую ему программу, позволяющую находить элементы, обратные к элементам, взаимно простым с модулем кольца;
    \item Составьте алгоритм и напишите соответствующую ему программу, позволяющую возводить в натуральную стпень элементы кольца вычетов.
\end{enumerate}

\clearpage

\section{Используемые технологии}

Программа написана на языке программирования Python 3.9. Плюсом данного решения стало то, что ЯП Python
поддерживает работу с большими целыми числами и это позволило легко написать тесты для моей
программы. Программа использует только стандартную библиотеку Python, установка сторонних зависимостей
не требуется.

\clearpage

\section{Структура программы}

Вся программа состоит из трёх файлов:
\begin{enumerate}
    \item Основная программа (\textit{bigint.py}). В данном файле содержится класс \textit{BigInt},
    который позволяет совершать арифметические операции с длинными целыми числами. Для удобства работы
    с данным классом были перегружены основные арифметические операторы (такие как <<+>>, <<->>, <<*>> и пр.)
    и это позволило работать с объектами данного класса как с обычными числами.
    \item Библиотека функций для длинной арифметики (\textit{long\_math.py}). В данном файле содеражатся
    функции, которые работают с длинными числами и вызываются из класса \textit{BigInt}. Блок-схемы данных
    функций будут представлены ниже.
    \item Тесты работы программы (\textit{tests.py}). В данном файле содержатся юнит-тесты со следующим принципом работы:
    \begin{enumerate}
        \item Случайно выбираем 2 числа в промежутке от $-10^{30}$ до $10^{30}$;
        \item Преобразуем их в тип \textit{BigInt}. После этого у нас будет 2 пары одинаковых чисел. Одна пара типа
        \textit{int} из стандартной библиотеки, а вторая типа \textit{BigInt};
        \item Производим арифметические действия на обеих парах чисел и сравниваем получившиеся результаты.
        Если результаты отличаются, то выводим ошибку;
        \item Выполняем предыдущие пункты 100000 раз.
    \end{enumerate}
\end{enumerate}

\clearpage

\section{Описание используемых алгоритмов}

\subsection{Сложение}
Сложение реализовано в функции \textit{l\_add}. Для сложения используется алгоритм описанный в \cite{zavg}.

\subsection{Вычитание}
Вычитание реализовано в функции \textit{l\_sub}. Для вычитания используется алгоритм описанный в \cite{zavg}.

\subsection{Умножение}
Умножение реализовано в функции \textit{l\_mul}. Для умножения используется исправленный алгоритм умножения из \cite{zavg}.
Были внесены следующие изменения (синие строки были изменены, красные удалены, а зелёные добавлены):
\begin{enumerate}
    \item Вводим числа \textit{x} и \textit{y} в строковые переменные \textit{s1} и \textit{s2} соответственно.
    \item Определяем длины \textit{l1} и \textit{l2} строк \textit{s1} и \textit{s2} соответственно.
    \item Полагаем \textit{m} = max\{\textit{l1}, \textit{l2}\}
    \color{blue}
    \item Полагаем \textit{k} = (\textit{m} - 1) / 4 + 1
    \color{black}
    \item Полагаем \textit{n} = 4 * \textit{k}
    \item Дописываем \textit{n} - \textit{l1} нулей в начало строки \textit{s1} и \textit{n} - \textit{l2} нулей в началов строки \textit{s2}
    \color{blue}
    \item Полагаем \textit{osn} = $10^4$, \textit{st} = '0', \textit{n1} = \textit{n}
    \color{black}
    \item Цикл при изменении переменной \textit{j} от 1 до \textit{k} выполняем:
    \begin{enumerate}
        \color{red}
        \item Полагаем \textit{n1} = \textit{n} и \textit{w} = 0
        \color{black}
        \item Из строки \textit{s2} считываем 4 символа, начиная с позиции \textit{n1} - 3, преобразуем их в числовой формат и присваиваем целочисленной переменной \textit{b}.
        \color{green}
        \item Полагаем \textit{n2} = n, \textit{w} = 0, \textit{s3} = 0
        \color{black}
        \item Цикл при изменении переменной \textit{i} от 1 до \textit{k} выполняем:
        \begin{enumerate}
            \item Из строки \textit{s1} считываем 4 символа, начиная с позиции \textit{n} - 3, преобразуем их в числовой формат и присваиваем целочисленной переменной \textit{a}.
            \item Находим величину \textit{c} = \textit{a} * \textit{b} + \textit{w}
            \item Если \textit{c} < \textit{osn}, то \textit{z} = \textit{c}, \textit{w} = 0, иначе \textit{z} = \textit{c} \% \textit{osn}, \textit{w} = \textit{c} / \textit{osn}
            \item Преобразуем число \textit{z} в строковый формат и присваиваем строковой переменной \textit{s}.
            \item Если длина \textit{l} строки \textit{s} меньше 4, то дописываем 4 - \textit{l} нулей в начало строки \textit{s}.
            \item В начало строки \textit{s3} дописываем четыре символа строки \textit{s}.
            \color{red}
            \item Полагаем \textit{n} = \textit{n} - 4 и \textit{i} = \textit{i} + 1
            \color{black}
            \color{green}
            \item Полагаем \textit{s3} = \textit{s} + \textit{s3}, \textit{n2} = \textit{n2} - 4, \textit{i} = \textit{i} + 1
            \color{black}
        \end{enumerate}
        \item Если после выполнения \textit{i}-цикла имеем \textit{w} $\neq$ 0, то число \textit{w} преобразуем в строковый формат и полученную строку добавляем в начало строки \textit{s3}.
        \item Дописывем 4(\textit{j}-1) нулей в конец строки \textit{s3}.
        \item Используя алгоритм сложения, складываем числа, записанные в строках \textit{st} и \textit{s3}; результат сложения записывем в строковую переменную \textit{st}.
        \item Полагаем \textit{n1} = \textit{n1} - 4 и \textit{j} = \textit{j} + 1
    \end{enumerate}
\end{enumerate}

\subsection{Деление с остатком}
Деление с остатком реализовано в функции \textit{l\_divmod}. В качестве алгоритма используется деление в столбик
с небольшими модификациями для ускорения работы и сокращения количества итераций.

\subsection{Возведение в степень}
Возведение в степень реализовано в функции \textit{l\_pow}. Для возведения числа в степень используется алгоритм описанный в \cite{zavg}.

\subsection{Вычисление корня из натурального числа}
Вычисление корня из натурального числа реализовано в функции \textit{l\_root}. Для вычисление корня используется алгоритм описанный в \cite{zavg}.

\subsection{НОД}
В программе реализовано 3 алгоритма вычисления НОД:

\begin{enumerate}
    \item Расширенный алгоритм Евклида \cite{zavg} (реализован в методе \textit{BigInt.gcd})
    \item Расширенный бинарный алгоритм \cite{zavg} (реализован в методе \textit{BigInt.bin\_gcd}).
    В предложенной реализации содержится ошибка, которую мне не удалось исправить, т. к. она возникает не во всех случаях (примерно 5-10 раз на 100 запусков).
    Из-за этой ошибки в данном алгоритме в некоторых случаях некорректно вычисляются коэффициенты линейного представления НОД.
    Пример: $НОД(927, 238) = 1$, при этом $u = 257, v = 100$, что, очевидно, неверно. Правильные значения $u$ и $v$ это $19$ и $-74$ соответственно: $927 * 19 + 238 * (-74) = 1$.
    \item Алгоритм LSBGCD \cite{zavg} (реализован в методе \textit{BigInt.lsbgcd}). В исходный алгоритм, предложенный в \cite{zavg} были внесены следующие изменения:
    \begin{itemize}
        \item Первое и самое главное изменение содержится в пункте алгоритма 3.1: <<Найти число \textit{n} такое, что $2^n y \leq x < 2^{n+1}y$>>.
        В \cite{zavg} предлагается \textbf{на каждой} итерации основного цикла полагать $n = log_2(10) \cdot L_{10}(y)$. Однако, посмотрев как меняется $n$, я пришёл к выводу, что начинать
        поиск с этого значения на \textbf{каждой} итерации цикла не оптимально, т.к. $n$ изменяется на малую величину (максимальное увиденное мной изменение переменной $n$ равнялось $4$),
        а следовательно, разумно будет поменять алгоритм следующим образом:
        \begin{itemize}
                \item \textbf{До} основного цикла полагаем $n = log_2(10) \cdot L_{10}(y)$.
                \item На каждой итерации цикла осуществляем поиск нового $n$, начиная с предыдущего $n$.
        \end{itemize}
        В моём случае данная оптимизация ускорила алгоритм практически в 8 раз!
        \item Арифметические выражения и цикл поиска значения $n$ были слегка переработаны таким образом, чтобы $2^n$ можно было вынести в переменную.
    \end{itemize}
\end{enumerate}

\subsection{Сложение в кольце вычетов}
Сложение реализовано в методе \textit{BigInt.ring\_add}. Для сложения используется алгоритм описанный в \cite{zavg}.

\subsection{Вычитание в кольце вычетов}
Вычитание реализовано в методе \textit{BigInt.ring\_sub}. Для вычитания используется алгоритм описанный в \cite{zavg}.

\subsection{Умножение в кольце вычетов}
Умножение реализовано в методе \textit{BigInt.ring\_mul}. Для умножения используется алгоритм описанный в \cite{zavg}.

\subsection{Обратные элементы в кольце вычетов}
Вычисление обратных элементов реализовано в методе \textit{BigInt.ring\_inv}. Для вычисления обратных элементов используется алгоритм описанный в \cite{zavg}.

\subsection{Возведение в степень в кольце вычетов}
Возведение в степень реализовано в методе \textit{BigInt.ring\_pow}. Для возведения в степень используется алгоритм описанный в \cite{zavg}.

\section{Блок-схемы алгоритмов}
Ниже представлены блок-схемы функций, используемых для работы с длинными числами.
\includepdf{pdfs/add.pdf}
\includepdf{pdfs/sub.pdf}
\includepdf[pages=-]{pdfs/mul.pdf}
\includepdf{pdfs/divmod.pdf}
\includepdf{pdfs/pow.pdf}
\includepdf{pdfs/root.pdf}
\includepdf{pdfs/bin_gcd.pdf}
\includepdf{pdfs/lsbgcd.pdf}
\includepdf{pdfs/ring_add_sub_mul.pdf}
\includepdf{pdfs/ring_inv.pdf}
\includepdf{pdfs/ring_pow.pdf}

\clearpage

\section{Примеры работы программы}

Инициализруем несколько переменных объектами типа \textit{BigInt} и посмотрим на результаты арифметических операций:

\lstinputlisting{example_1.py}

Вывод программы:
\begin{itemize}
    \item x1 = 99999999999999999999
    \item y1 = 11111111111111111111
    \item x2 = 99
    \item y2 = 11
    \item N = 12345678998765432
    \item x1 + y1 = 111111111111111111110
    \item x1 - y1 = 88888888888888888888
    \item x1 * y1 = 1111111111111111111088888888888888888889
    \item x1 / y1 = 9
    \item x1 mod y1 = 0
    \item $x2 ^{y2}$ = 8953382542587164451099
    \item Корень из x2 степени y2 = 1
    \item НОД(x1, y1) = 11111111111111111111
    \item (x1 + y1) mod N = 122222223110
    \item (x1 - y1) mod N = 97777778488
    \item (x1 * y1) mod N = 21010000081689
    \item $x1 ^{(-1)} mod N$ = 5264157999473642
    \item $x2 ^{y2} mod N$ = 12182065501559763
\end{itemize}

\clearpage

\section{Список литературы}

\nocite{*}

\printbibliography[heading=none]

\clearpage

\section{Исходный код}

Ниже приведён исходный код программы. К сожалению, пакет \textit{listings} для \LaTeX{} очень плохо работает с
русскими символами. Из-за этого русскоязычная часть программы стала плохо читаема.

\subsection{bigint.py}
\lstinputlisting{bigint.py}
\clearpage

\subsection{tests.py}
\lstinputlisting{tests.py}
\clearpage
